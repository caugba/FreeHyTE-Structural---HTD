function MainTri
% MAINREG Command center of the FreeHyTE - Structural HTD module with
% regular rectangular meshes.
%
% MAINREG is called upon exiting the data input (GUI) phase of the module.
% It is used to call all functions required for the solution of the 
% structural problem and centralize all data they provide. 
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Structural HTD User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHWWkyb2xmTGhLa1k
% 4. Barbosa C - Algoritmo 'p'-adaptativos com indicadores de erros globais
% e locais para problemas de elasticidade, MSc Thesis, Universidade Nova de Lisboa,
% 2022 (in Portuguese).

close all;

%% Pre-processing

% Launch pre-processing routine
% * NGP is the number of Gauss points for the line integration;
% * Nodes is a (NNODE x 2) matrix, where NNODE is the number of nodes in 
% mesh. It stores the coordinates of each node;
% * Edges, Loops and BConds are data structures storing information
% on the edges, finite elements (loops) and boundary conditions,
% respectively. They are documented in Section 5.3 of reference [2];
% * NoDiv is the number of points for plotting the colormaps of the
% solution, in each Cartesian direction.
[NGP, Nodes, Edges, Loops, BConds, NoDiv] = InputProcTri;

% Check if the initial domain basis aproximation satisfies the 'kinematic'
% ideterminacy condition and correct if necessary. The kinematic
% indeterminacy condition is covered in Section 3.4.2 of reference [2],
% section 4.5.2 of reference [3], and section 4.4 of reference [4].
[Loops,Edges] = CheckMinOrders(Loops,Edges,BConds); 

% Load the analysis type option
% RunOption = 1 - single analysis
% RunOption = 2 - adaptive algorithm
load('StructDef','RunOption');

% RunOption=2;

% ASSIGNPARTS maps the finite element solving system and assigns entries
% and dimensions to elements and sides. The information is used by the
% functions that generate the blocks of the solving system to insert them
% at the right positions.
% * Dim is the total dimension of the finite element solving system;
% * the mapping of the solving system is covered in Section 6.2 of
% reference [2].
[Edges,Loops,Dim] = AssignParts(Edges, Loops, BConds);

% Stores the coordinate of the beginning of the Edges' part in the global 
% system
Edges.Edgeinsert=Loops.insert(end)+Loops.dim(end); 

% Initialization of the matrix of coefficients and the free vector
% * LHS is the matrix of coefficients of the solving system;
% * RHS is the free vector of the solving system.
LHS = zeros(Dim);
RHS = zeros(Dim,1);

% Initialization of Gauss-Legendre weights & abscissas (on a -1:1
% interval). gauleg is a external routine, written by Greg von Winckel.
[abscissa,weight] = gauleg(NGP, -1, 1);

%% Generation of the solving system
% Generation & allocation of the blocks in the matrix of coefficients.
% General mapping of the matrix of coefficients of hybrid-Trefftz elements:
%   _______________________________________________              _______
%  |       |       |       |       |       |       |  <------>  |       |
%  |  K11  |  K12  |  K13  |  K14  |   0   |   B1  |            |   T1  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K21  |  K22  |  K23  |  K24  |   0   |   B2  |            |   T2  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K31  |  K32  |  K33  |  K34  |   0   |   B3  |            |   T3  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K41  |  K42  |  K43  |  K44  |   0   |   B4  |            |   T4  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |   0   |   0   |   0   |   0   |   0   |   B5  |            |   T5  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |   B1  |   B2  |   B3  |   B4  |   B5  |   0   |            |  -U   |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%
%
% The stiffness and boundary matrices of hybrid-Trefftz elements have 
% entries that correspond to the parts of the bases generated by odd and 
% even, harmonic and biharmonic potentials:
% * 1 - basis generated by odd harmonic potentials;
% * 2 - basis generated by even harmonic potentials;
% * 3 - basis generated by odd biharmonic potentials;
% * 4 - basis generated by even biharmonic potentials;
% * 5 - rigid body modes (no stiffness).
%
% The following functions generate the coefficients blocks for each finite
% element and essential boundary and insert them at the right place,
% according to the mapping information generated in ASSIGNPARTS. Since the
% system is symmetric, Kij blocks are calculated and Kji blocks are
% inserted directly.
%
% The explicit expressions of the stiffness and boundary matrices are given
% in Chapter 3 of reference [4].
LHS = K11(Edges, Loops, LHS, abscissa, weight);
LHS = K12(Edges, Loops, LHS, abscissa, weight);
LHS = K13(Edges, Loops, LHS, abscissa, weight);
LHS = K14(Edges, Loops, LHS, abscissa, weight);
LHS = K22(Edges, Loops, LHS, abscissa, weight);
LHS = K23(Edges, Loops, LHS, abscissa, weight);
LHS = K24(Edges, Loops, LHS, abscissa, weight);
LHS = K33(Edges, Loops, LHS, abscissa, weight);
LHS = K34(Edges, Loops, LHS, abscissa, weight);
LHS = K44(Edges, Loops, LHS, abscissa, weight);
LHS = B1(Edges, Loops, LHS, abscissa, weight);
LHS = B2(Edges, Loops, LHS, abscissa, weight);
LHS = B3(Edges, Loops, LHS, abscissa, weight);
LHS = B4(Edges, Loops, LHS, abscissa, weight);
LHS = B5(Edges, Loops, LHS, abscissa, weight);


% Store the initial dimension of the solving system in GDL0
GDL0 = sum(sum(Edges.dim(:,:)),2)+sum(sum(Loops.dim(:,:)),2); 
display(GDL0);

% Generation & allocation of the blocks in the free vector.
% The general mapping of the free vector is consistent to that of the
% coefficient matrix (above). The terms corresponding to the stiffness
% matrices (Ti) represent generalized tractions applied to the Neumann
% boundaries of the mesh. The terms corresponding to the boundary matrices
% (U) represent generalized displacements applied to the Dirichlet
% boundaries of the mesh, or are null if the boundary is interior.
%
% The following functions generate the free vectors for each finite
% element and essential boundary and insert them at the right place,
% according to the mapping information generated in ASSIGNPARTS. 
%
% The explicit expressions of the free vectors are given in Chapter 3 of 
% reference [4].
RHS = T1(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T2(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T3(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T4(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T5(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = U(Edges, BConds, RHS, abscissa, weight);

%% Pre-conditioning and solution of the solving system
% Pre-conditioning and storage of the solving system
%
% * the solving system is pre-conditioned using a scaling procedure aimed
% at reducing its diagonal elements to unity while preserving the symmetry
% of the original system;
% * the scaling procedure is described in Section 6.2 of reference [2];
% * if the system results too large for the storage memory available to
% Matlab, it is stored in a sparse form.
%
% Generating the scaling matrix, Sc. Sc is a diagonal matrix, whose terms
% are defined as the inverse of the square roots of the diagonal terms of
% the coefficient matrix.
Sc = sqrt(diag(LHS)).^-1;

% If the diagonal term is null, the respective line and column remain
% unscaled.
Sc(isinf(Sc)) = 1;

% Computing the scaled versions of the LHS & RHS
ScLHS = bsxfun(@times,bsxfun(@times,Sc',LHS),Sc);
ScRHS = Sc .* RHS;

% Checking for ill-conditioning in the system
CndNo = rcond(ScLHS); 
display(CndNo);

if  CndNo<eps %2.2204e-16
    % if the reciprocal of cond number is larger than machine's precision
    % then the execution proceeds to the next iteration.      
    
    if  RunOption==1 % system is unstable, but a single run is required
            warning('local:NumericalChk',...
                'System condition number is %0.5g. Results might be inaccurate.\n',...
                CndNo);
        % Moore-Penrose pseudoinverse-based solution procedure
        ScX = pinv(ScLHS)*ScRHS;                         
    else   % system is unstable, and a p-adaptive run is required
        error('local:NumericalChk',...
            'System condition number is %0.5g. ill-contitioned system is not accepted in the first run of adaptive analyses.',CndNo);
    end               

else
    % Default solution procedure
    ScX = ScLHS\ScRHS;
    
end

% Reverting the scaling of the solution
X = Sc .* ScX;

%% Post-processing for the single run analysis
%
% If a single analysis is required, construct the displacement and stress 
%fields and plot the solution. 



if(RunOption==1)
    disp('passed here :)')
    % 'iteration' number in the file name is set to zero to indicate a
    % single run.
    iteration = 0;
    
    % COMPUTEFIELDSREG returns the values of the fields in a NoDiv x NoDiv grid
    % in each element, but these values are not used, by default.
    [~, ~, ~, ~, ~] = ComputeFieldsTri(NoDiv, Nodes, Edges, Loops,X);

    % House cleaning: restoring warnings
    warning('on','MATLAB:DELETE:FileNotFound');
    warning('on','MATLAB:load:variableNotFound');
    
    % The solution energy is computed according to Section 3.7 of of 
    % reference [4]. In single run analyses, the solution energy is not
    % directly used.
    Energy = (1/2)*(X(1:Edges.Edgeinsert-1)).'*...
        LHS(1:Edges.Edgeinsert-1,1:Edges.Edgeinsert-1)*...
        (X(1:Edges.Edgeinsert-1));
        display(Energy);
    
    % single run - stops execution and returns
    return; 
end
%% ******** END OF SINGLE RUN ANALYSIS ********

%% ******** ADAPTIVE ALGORITHM INITIALIZATION *******
% The algorithm only gets to this point is an adaptive analysis was
% requested. The initial analysis is completed at this point.

% Saving the coefficients matrix from the initial run to avoid its
% recalculation
ScLHS0=ScLHS; 

% Storing the initial refinements. Since no SV outliers were identified in
% the first run, the solving system is assumed stable. Edges.stable and 
% Loops.stable fields of the Edges and Loops structures store the last
% orders of the boundary and domain bases for which no outliers were found.
Edges.stable = Edges.order;     
Loops.stable = Loops.order;

% Computing the initial solution energy, according to Section 3.7 of 
% reference [4].  
Energy0 = (1/2)*(ScX(1:Edges.Edgeinsert-1)).'*...
    ScLHS(1:Edges.Edgeinsert-1,1:Edges.Edgeinsert-1)*...
    (ScX(1:Edges.Edgeinsert-1));

% EdgesDirichlet is a list with all Dirichlet edges
EdgesDirichlet=strfind(Edges.type','D');

% Initialization
% * ErrorNorm is the value of the error associated to the current stopping
% criterion (see Section 6.3.3 of reference [2]). Depending on the
% stopping criterion, it may represent the average energy variation, 
% computed according over the last AvgNVal iterations (energy convergence
% stopping criterion), or the average boundary residual, also computed over
% the last AvgNVal iterations;
% * iteration is the current iteration;
ErrorNorm = 1;
iteration = 1;
glistposition=1;

% LIST is a structure where the algorithmic data of the iterative process
% is stored. It consists of two types of variables:
% * variables with names ending in 'It', which are typically lists that
% function as a logbook of the iterative process; and,
% * variables without 'It' which are local to (and overwritten at) each 
% iteration.
% The fields of the LIST structure are fully described in Section 5.3.3 of
% reference [4].
% List.EnergyIt is a vector with the solution energy at each iteration.
List.EnergyIt(iteration)=0;

% Load p-adaptive algortihmic parameters defined by the user in the GUI.
% The definiton of these parameters and their recommended values are given
% in Section 4.5.6 of reference [3].

load('Adaptive','TargetErrorNorm','SelectionTol','MaxOutlierIter',...
    'SelectionCriterion','thresh', 'MinIter','AvgNVal','StoppingCriterion');
    
% The SelectionCriterion value coming from the GUI must be incremented, as
% the first column in List.Edge is the index.

% % % % %%Adicionado temporariamente para correr o código:
% % % % 
% % % % 
% % % % % StoppingCriterion=1 %1 energy ; 2 bnd
% % % % % SelectionCriterion=2 %1 bnd ; 2 energy
% % % % StoppingCriterion=2 %1 energy ; 2 bnd
% % % % SelectionCriterion=1 %1 bnd ; 2 energy
% % % % TargetErrorNorm=1.0e-04
% % % % % SelectionTol= 1.0e-5 %1.0e-5 %0.99 %0.9 %0.6
% % % % SelectionTol= 0.5
% % % % % SelectionTol= 0.9
% % % % %Utilizado pela MRG - 10e-8
% % % % %Valor limite quando usa o critério da energia deformação = 10e-4 
% % % % %Valor limite quando usa o critério da densidade máxima do resíduo na fronteira = 10e-2
% % % % AvgNVal= 3 %Ou 4
% % % % MaxOutlierIter= 16 %16 %10
% % % % thresh=1.000000000000000e-12 %Zero numérico / Precisão da máquina: eps = 2.2204e-16
% % % % MinIter=5
% % % % 
% % % % SelectionCriterion = SelectionCriterion + 2;


%% ******** ADAPTIVE ALGORITHM BODY ********
% This is the main body of the adaptive algorithm, ran iteratively until
% the convergence is reached (or some other stopping criterion is met).
% The functioning of the adaptive p-refinenent process is documented in
% Section 6.3 of reference [2], Sections 4.5.3 to 4.5.6 of reference [3]
% and in in Chapters 4 of reference [4].
%
% The adaptive refinement is performed by increasing the orders of the 
% approximation bases of some boundaries, selected based on either a global
% or a local selection criteria.
% The refinement of the domain bases is a consequence of the boundary
% refinement to ensure the indeterminacy and numerical stability of the
% solving system.

%% Begin iterative process, until the convergence (or some stopping criterion) are reached
while ErrorNorm > TargetErrorNorm % checking for convergence
    
    %% Initialization
    display(iteration);
    
    % Initializing structures resposible for the edge refinement management
    % * List.Edge is an NDNBx5 matrix, where NBND is the total number of
    % boundaries of the mesh. The columns list the index of the boundary,
    % its direction and the values of the two selection criteria. 
    % The selection criteria are the boundary balance and energy residuals, 
    % computed as shown in Section 6.3 of reference [2];
    % * List.SpuriousEdges lists the edges whose incrementation would cause
    % spurious (i.e. zero energy) modes;
    % * List.EdgesToRefine lists the edges to refine in the current 
    % iteration.
    List.Edge=[];List.SpuriousEdges=[];List.EdgesToRefine=[];

    %% Selection of the boundaries to refine
    % For each essential boundary, the values of the boundary balance and 
    % energy residuals are computed and stored in the List structure 
    % (List.Edges), ranked according to the (user) defined 
    % SelectionCriterion.
    
    listposition = 1;
    for i=1:length(EdgesDirichlet)
        for a=1:2 %1 represent the normal direction and 2 tangencial direction
        index=EdgesDirichlet(i);
            if ~isnan(Edges.order(index,a))
            [Edges,Loops,List] = EdgeRefinement(Edges,Loops,BConds,Sc,...
                ScLHS0,Energy0,abscissa,weight,ScX,List,Dim,index,iteration,...
                List.EnergyIt,SelectionCriterion,a,listposition);
            listposition = listposition+1;
            end
        end
    end
    
    % Selects the edges to refine. The boundaries selected for refinement
    % are the boundary with the highest value of the selection criterion
    % (SC), and all boundaries for which the selection criteria are within
    % a specified selection tolerance (SelectionTol) from the highest
    % value. See Section 6.3.2 of reference [2].
    % ExitScore is zero if the selection crietria for all boundaries are
    % inferior to a 'numerical zero' threshold (thresh).
    [List,ExitScore] = SelectEdgesToRefine(List,SelectionCriterion,...
        SelectionTol,thresh);
    
    % If the selection criterion is smaller than the threshold for all 
    % boundaries, it exits the while cycle. The most probable cause is that
    % the exact solution is already contained in the basis, so refinement
    % increments would not bring any improvement.
    if ~ExitScore   
        break;
    end
    
    % The approximation basis order of all edges marked for refinement are
    % increased by one.
    
    for i=1:size(List.EdgesToRefine,1) 
        Edges.order(List.EdgesToRefine(i,1),List.EdgesToRefine(i,2))= ...
            Edges.order(List.EdgesToRefine(i,1),List.EdgesToRefine(i,2))+1;
        Edges.dim(List.EdgesToRefine(i,1),List.EdgesToRefine(i,2))= ...
            Edges.dim(List.EdgesToRefine(i,1),List.EdgesToRefine(i,2))+1;
    end    
    
    % The relevant iteration dependent information is stored for posterior 
    % convergence plotting.
    % * List.RefinedEdgesIt lists the edges refined in the current iteration 
    % * List.ErrorEdgeNormIt lists the largest boundary balance residual in
    % the current iteration.
    List.RefinedEdgesIt{iteration,:}=List.EdgesToRefine;
%     for i=1:size(List.EdgesToRefine,1)
%         List.RefinedEdgesIt(glistposition,1)=iteration;
%         List.RefinedEdgesIt(glistposition,2)=List.EdgesToRefine(i,1);
%         List.RefinedEdgesIt(glistposition,3)=List.EdgesToRefine(i,2);
%         glistposition = glistposition + 1;
%     end 
   
    List.ErrorEdgeNormIt(iteration)=List.Edge(1,3); 

     %% Selection of the domains to refine
    % There are three possible causes for domain refinement: 
    % * the first is the need to refine a boundary whose refinement would 
    % yield spurious modes. This should not normally happen, but it might,
    % if the threshold (thresh) for calling a spurious mode is set too
    % high. If this happens, the elements adjacent to the boundaries to 
    % refine are also refined;
    % * the second is if the indeterminacy number of certain elements 
    % becomes equal or less than zero because of the refinement of adjacent
    % boundaries;
    % * the third is if after the refinement of the edges, the order of an 
    % edge becomes larger then the order of an element adjacent to it. 
    % Then the domain order must also be increased.
    
    % Identify boundaries with spurious modes selected for refinement
    List.SpurEdgeToRefine = intersect(List.EdgesToRefine,List.SpuriousEdges);
    
    % Initialization of the element (loop) refinement procedure.
    % * List.LoopsToRefine is a vector that contains the elements to refine
    % * RefinedLoopsIt store the elements refined at each iteration.
    List.LoopsToRefine = [];
    List.RefinedLoopsIt{iteration,:} = [];
      
    % Identify the elements (loops) to be refined
    List = SelectLoopsToRefine(Loops,Edges,List,iteration);
    
    % The orders of the approximation bases order of all loops marked for 
    % refinement are increased by one
    Loops.order(List.LoopsToRefine)=Loops.order(List.LoopsToRefine)+1;

  %% Rebuilding and solving the finite element system
    % Rebuild the system according to the newly selected bases orders.
    % If multiple boundaries are selected for refinement, it is possible
    % that the system becomes ill conditioned even if none of the added
    % modes would be spurious if selected on its own. 
    % If the system is not stable, the order of the elements 
    % adjacent to the refined boundaries are automatically increased to 
    % improve the stability of the system.
    % If the system continues ill conditioned after MaxOutlierIter several attempts, 
    % the algorithm quits. However, the program returns the last stable
    % solution.
    
    % Initializing parameters
    % * Outliers is a flag signaling the presence of SV outliers;
    % * RevertAndExit is a flag signaling that MaxOutlierIter iterations
    % with SV outliers were performed. The last stable solution is returned
    % in this case;
    % * OutIt is the number of iterations with SV outliers.
    Outliers= 1;
    RevertAndExit = 0;
    OutIt=1;    
 
    % Begin rebuilding, while checking for outliers in the system.
    while  Outliers && ~RevertAndExit % runs while outliers are detected
            
        % Mapping the solving system. Please see the comments to the 
        % ASSIGNPARTS function.
        [Edges,Loops,Dim] = AssignParts(Edges, Loops, BConds);
        % The system construction procedure is identical to that of the
        % first iteration.
        Edges.Edgeinsert=Loops.insert(end)+Loops.dim(end); 
        LHS = zeros(Dim);
        RHS = zeros(Dim,1);
        LHS = K11(Edges, Loops, LHS, abscissa, weight);
        LHS = K12(Edges, Loops, LHS, abscissa, weight);
        LHS = K13(Edges, Loops, LHS, abscissa, weight);
        LHS = K14(Edges, Loops, LHS, abscissa, weight);
        LHS = K22(Edges, Loops, LHS, abscissa, weight);
        LHS = K23(Edges, Loops, LHS, abscissa, weight);
        LHS = K24(Edges, Loops, LHS, abscissa, weight);
        LHS = K33(Edges, Loops, LHS, abscissa, weight);
        LHS = K34(Edges, Loops, LHS, abscissa, weight);
        LHS = K44(Edges, Loops, LHS, abscissa, weight);
        LHS = B1(Edges, Loops, LHS, abscissa, weight);
        LHS = B2(Edges, Loops, LHS, abscissa, weight);
        LHS = B3(Edges, Loops, LHS, abscissa, weight);
        LHS = B4(Edges, Loops, LHS, abscissa, weight);
        LHS = B5(Edges, Loops, LHS, abscissa, weight);
        RHS = T1(Edges, Loops, BConds, RHS, abscissa, weight);
        RHS = T2(Edges, Loops, BConds, RHS, abscissa, weight);
        RHS = T3(Edges, Loops, BConds, RHS, abscissa, weight);
        RHS = T4(Edges, Loops, BConds, RHS, abscissa, weight);
        RHS = T5(Edges, Loops, BConds, RHS, abscissa, weight);
        RHS = U(Edges, BConds, RHS, abscissa, weight);
        
        % Check if the maximum orders of the domain and boundary bases 
        % were reached.
        
        MaxOrder = 20;
        [ErrorNorm,Stop]=CheckMaxOrders(Loops,Edges,ErrorNorm);       
        
        
        % Generating the scaling matrix, Sc. Sc is a diagonal matrix, whose terms
        % are defined as the inverse of the square roots of the diagonal terms of
        % the coefficient matrix.
        Sc = sqrt(diag(LHS)).^-1;
        
        % If the diagonal term is null, the respective line and column remain
        % unscaled.
        Sc(isinf(Sc)) = 1;
        
        % Computing the scaled versions of the LHS & RHS
        ScLHS = bsxfun(@times,bsxfun(@times,Sc',LHS),Sc);
        ScRHS = Sc .* RHS;

        % Checking for ill-conditioning in the system
        CndNo = rcond(ScLHS); 
        List.CndNoIt(iteration,:)=CndNo;
       
        if  CndNo>eps %2.2204e-16
            % if the reciprocal of cond number is larger than machine's precision
            % then the execution proceeds to the next iteration.      
            Outliers=0;            
            OutIt=0;                
           
        else % if the system is ill-conditioned, the loops adjacent to the refined
             % boundaries will also be refined
            
            % Reset the list with the loops to refine 
            List.LoopsToRefine = [];
            
            % Identify the elements (loops) which are adjacent to the
            % boundaries selected for refinement.
            for i=1:length(List.EdgesToRefine)
                index = List.EdgesToRefine(i);
                List.LoopsToRefine = cat(2,List.LoopsToRefine,... 
                    Edges.lleft(index),Edges.lright(index)); 
            end
            
            % Eliminating the repeated loops and the zero entries (the
            % latter correspond to right elements of exterior boundaries.
            List.LoopsToRefine = unique(List.LoopsToRefine);
            List.LoopsToRefine = List.LoopsToRefine(List.LoopsToRefine~=0); 
            
            % Add newly refined elements to the list of those refined in
            % the current iteration
            List.RefinedLoopsIt{iteration,:} = ...
                cat(2, List.RefinedLoopsIt{iteration,:},...
                List.LoopsToRefine);
            
            % Increment the orders of the elements to be refined
            Loops.order(List.LoopsToRefine)=Loops.order(List.LoopsToRefine)+1;
            
            % Setting flags to be able to diagnose forced exits
            % * If the max no of iterations with outliers was reached, sets
            % RevertAndExit to 2;
            % * If the maximum order of a basis was reached, (Stop == 1),
            % sets RevertAndExit to 1;
            if OutIt==MaxOutlierIter 
                RevertAndExit=2;
                Edges.order=Edges.stable;  
                Loops.order=Loops.stable;
            elseif Stop==1 
                RevertAndExit=1;
                Edges.order=Edges.stable;  
                Loops.order=Loops.stable;
            end
            
            OutIt=OutIt+1;
            
        end
        
    end
            
    %% Dealing with revert & exit scenarios
    % At this point, we have the following scenarios:
    % - Stop = 0 (Máxima ordem não atingida) & RevertAndExit = 0 (Outlier não identificado): solve the system & proceed
    % - Stop = 1 (Máxima ordem atingida) & RevertAndExit = 0 (Outlier não identificado): max refinement reached and no outliers - solve the system & quit
    % - Stop = 1 (Máxima ordem atingida) & RevertAndExit = 1 (Outlier identificado mas MaxOutlierIter iterations não atingida): max refinement reached and outliers - revert & quit
    % - Stop = 1 (Máxima ordem atingida) & RevertAndExit = 2(MaxOutlierIter iterations atingida): max refinement reached and max outlier iterations reached - revert & quit
    
    %% Dealing with revert & exit scenarios
    if RevertAndExit
        % system needs to be remapped for the last stable configuration
        [Edges,Loops] = AssignParts(Edges, Loops, BConds); 
        
        %if the orders had to be reverted to the last stable configuration
        %it registers 'Reverted' in the iteration logbooks.
        List.RefinedLoopsIt{iteration,:} = 'Reverted';
        List.RefinedEdgesIt{iteration,:} = 'Reverted';
        
        % Storing iteration dependent stuff for posterior convergence plotting
        % removes the last edge error norm from the list (reverted iteration)
        List.ErrorEdgeNormIt = List.ErrorEdgeNormIt(1:iteration-1); 
        if RevertAndExit == 1
            warning('The maximum order of refinement was reached and SVD outliers were reported. Reverting to the last stable configuration...');
        else
            warning('The maximum number of consecutive systems with SVD outliers was reached. Reverting to the last stable configuration...');
        end
        
        % the other operations in the while ErrorNorm > TargetErrorNorm 
        % loop are not performed for RevertAndExit~=0
        break; 
    end
    
    %% Stable configuration protocol
    % The refinement process of the current iteration is sucessfuly 
    % completed and the relevenat information is stored.  
    Edges.stable = Edges.order;
    Loops.stable = Loops.order;
    ScLHS0=ScLHS;
    
    
    % Solving the scaled system by using default Matlab procedure
    ScX = ScLHS\ScRHS;
    % Scaling back the solution
    X = Sc .* ScX;
    
  
    % Computes the new solution energy and stores it for the next iteration
    List.EnergyIt(iteration)= (1/2)*(X(1:Edges.Edgeinsert-1)).'*...
        LHS(1:Edges.Edgeinsert-1,1:Edges.Edgeinsert-1)*...
        (X(1:Edges.Edgeinsert-1));
      
    % Calls StoreIterationInfo to insert the information about the current
    % iteration into the List structure
    List = StoreIterationInfo(Loops,Edges,List,iteration,Energy0);
    
    % Computes the values of the stopping criteria.
    % Computes the average error over the last AvgNVal+1 iterations
    % to check if it is below the convergence criterion,TargetErrorNorm.
    % At least MinIter are always performed, to avoid spurious early
    % convergence.
    if StoppingCriterion == 1 && iteration>=MinIter
        ErrorNorm=sum(List.EnergyVariationIt((iteration)-AvgNVal:...
            (iteration)))/(AvgNVal+1);
    elseif StoppingCriterion == 2 && iteration>=MinIter
        ErrorNorm=sum(List.ErrorEdgeVariationIt((iteration)-AvgNVal:...
            (iteration)))/(AvgNVal+1);
    end
    
    % If the maximum order was reached, it exists 
    if Stop == 1
        %load('Adaptive','MaxOrder');
        for j=1:length(Loops.area)
            if (Loops.order(j) >= MaxOrder)
                warning('The maximum order of refinement was reached for element %d. Try increasing the energy error set for convergece.',j);
            end
        end
        ErrorNorm = 0.0;  
    end
    
    % Updating the iteration number
    iteration=iteration+1;

end

%% ******** POSTPROCESSING ********
% Constructs the final temperature and flux fields, the final order map and
% the convergence graphs.

% After the end of the iterative process, updates the iteration number
iteration=iteration-1;
 
% Computing the temperature and flux fields and storing them in the
% Loops structure and a TecPlot file.
%[Loops] = ComputeFieldsReg(Nodes, Loops, X, iteration, abscissa);
[~, ~, ~, ~, ~] = ComputeFieldsTri(NoDiv, Nodes, Edges, Loops,X);

% Plotting the temperature and flux fields
%PlotFieldsReg(Nodes, Edges, Loops,abscissa);

% If no iterations have been performed, due to the initial
% solution having been exact already, it skips the rest. Otherwise, it
% constructs the convergence graphs.
if iteration ~= 0
   
    % Constructing the convergence graphs 
    GDLTotal=cat(2,GDL0,List.GDL_It);
    ConvGraphs(GDLTotal,List.EnergyIt,List.ErrorEdgeNormIt,...
        List.EnergyVariationIt, List.ErrorEdgeVariationIt,Energy0); 
    
    TABLE(List.GDL_It,List.BetaIt,...
    List.EnergyIt,List.LoopsOrderIt,List.EdgesOrderIt,...
    List.RefinedEdgesIt,List.RefinedLoopsIt,List.CndNoIt,TargetErrorNorm,...
    SelectionTol,MaxOutlierIter,SelectionCriterion,thresh,MinIter,AvgNVal,...
    StoppingCriterion);

end

end

